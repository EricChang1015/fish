<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <title>简易捕鱼游戏Demo - 多人版</title>
    <style>
        canvas {
            background: #eee;
            display: block;
            margin: 0 auto;
        }
    </style>
</head>
<body>
<canvas id="gameCanvas" width="800" height="600"></canvas>
<script>
    let canvas = document.getElementById('gameCanvas');
    let ctx = canvas.getContext('2d');
    let playerPosition = null; // 玩家位置：0为左侧，1为右侧
    let opponentPosition = {x: 100, y: 50}; // 假设对手初始位置在左上角
    let cannon = {x: 100, y: canvas.height - 50, width: 20, height: 50}; // 初始炮台位置
    let fishes = []; // 存储鱼的数组
    let bullets = [];

    // 创建WebSocket连接
    let ws = new WebSocket('ws://localhost:8080');

    ws.onopen = function () {
        console.log('WebSocket connection established');
    };

    ws.onmessage = function (event) {
        console.log('Received message:', event.data)
        let data = JSON.parse(event.data);
        if (data.result !== undefined) {
            console.log(data.result.hit ? '击中' : '未击中')
            let fishIndex = fishes.findIndex(fish => fish.id === data.result.fish.id);
            if (fishIndex >= 0) {
                if (data.result.hit) {
                    // 如果击中，从数组中移除鱼
                    fishes.splice(fishIndex, 1);
                } else {
                    // 如果未击中，处理其他逻辑，比如鱼闪烁效果
                    // ...
                }
            }
            return;
        }
        switch (data.action) {
            case 'setPosition':
                playerPosition = data.position;
                // 根据分配的位置调整炮台位置
                if (playerPosition === 1) { // 如果是右侧位置
                    cannon.x = canvas.width - 100; // 移动炮台到右侧
                    opponentPosition.x = 100; // 对手在左侧
                } else {
                    opponentPosition.x = canvas.width - 100; // 对手在右侧
                }
                break;
            case 'fireBullet': { // 接收新的炮弹数据并添加到bullets数组中
                let now = Date.now();
                let delay = now - data.bullet.timestamp; // 计算延迟
                let distance = (delay / 1000) * data.bullet.speed; // 假设速度单位是像素/秒，计算延迟时间内炮弹应该移动的距离
                // 根据延迟调整炮弹的初始位置
                data.bullet.x += distance * Math.cos(data.bullet.angle);
                data.bullet.y += distance * Math.sin(data.bullet.angle);
                bullets.push(data.bullet);
            }
                break;
            case 'fish': // 添加鱼到数组
                fishes.push(data.fish);
                break;

            case 'error':
                alert(data.message); // 显示错误消息
                break;
        }
    };

    canvas.addEventListener('click', function (event) {
        let now = Date.now(); // 获取当前时间戳
        let rect = canvas.getBoundingClientRect();
        let x = event.clientX - rect.left;
        let y = event.clientY - rect.top;
        let angle = Math.atan2(y - cannon.y, x - cannon.x);
        let bullet = {
            x: cannon.x,
            y: cannon.y,
            angle: angle,
            speed: 0.5,
            timestamp: now,
            owner: playerPosition,
            id: generateBulletID()
        };
        bullets.push(bullet); // 添加炮弹到数组
        ws.send(JSON.stringify({action: 'fireBullet', bullet: bullet}));
    });

    function generateBulletID() {
        return generateRandomString(12)
    }

    function generateRandomString(length) {
        let result = '';
        let characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        let charactersLength = characters.length;
        for (let i = 0; i < length; i++) {
            result += characters.charAt(Math.floor(Math.random() * charactersLength));
        }
        return result;
    }

    function update() {
        const now = Date.now();
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // 绘制玩家炮台
        ctx.fillStyle = 'black';
        ctx.fillRect(cannon.x - cannon.width / 2, cannon.y, cannon.width, cannon.height);

        // 绘制对手位置
        ctx.fillStyle = 'grey';
        ctx.fillRect(opponentPosition.x - cannon.width / 2, cannon.y, cannon.width, cannon.height);

        // 绘制和移动鱼
        fishes.forEach(fish => {
            // 根据鱼的速度和角度更新位置
            fish.x += fish.speed * Math.cos(fish.angle);
            fish.y += fish.speed * Math.sin(fish.angle);

            // 绘制鱼
            drawFish(fish);
            // 如果鱼移动出画布，从数组中移除
            if (fish.x < 0 || fish.x > canvas.width || fish.y < 0 || fish.y > canvas.height) {
                fishes.splice(fishes.indexOf(fish), 1);
            }
        });

        // 更新和绘制炮弹
        bullets.forEach(function (bullet, index) {
            // 根据实际经过的时间来更新位置
            let timeElapsed = (now - bullet.timestamp); // 计算自发射以来经过的毫秒数
            // 根据时间差和速度计算当前应该在的位置
            let distance = timeElapsed * bullet.speed; // 计算炮弹应该移动的距离
            bullet.x += distance * Math.cos(bullet.angle);
            bullet.y += distance * Math.sin(bullet.angle);
            // 更新炮弹时间戳为当前时间
            bullet.timestamp = now;
            ctx.beginPath();
            ctx.arc(bullet.x, bullet.y, 5, 0, 2 * Math.PI);
            ctx.fillStyle = bullet.owner === playerPosition ? 'blue' : 'red'; // 区分玩家和对手的炮弹颜色
            ctx.fill();
            if (bullet.x < 0 || bullet.x > canvas.width || bullet.y < 0 || bullet.y > canvas.height) {
                bullets.splice(index, 1);
            } else {
                // 检查炮弹是否击中鱼
                fishes.forEach(fish => {
                    if (checkCollision(fish, bullet)) {
                        // 子弹击中鱼，发送击中信息到服务器
                        ws.send(JSON.stringify({
                            action: "hit",
                            fish: {type: fish.type, id: fish.id},
                            bullet: {id: bullet.id}
                        }));
                        bullets.splice(index, 1);
                    }
                });
            }
        });
        requestAnimationFrame(update);
    }

    function checkCollision(fish, bullet) {
        // 假设fish和bullet都有x, y坐标，fish有一个hitboxSize表示可击中的大小
        let dx = fish.x - bullet.x;
        let dy = fish.y - bullet.y;
        // 计算两点间的距离
        let distance = Math.sqrt(dx * dx + dy * dy);

        // 假设鱼的击中范围是其图片的一半
        let hitboxSize = 100;
        // 如果子弹与鱼的距离小于鱼的击中范围，那么子弹击中了鱼
        return distance < hitboxSize;

    }


    function drawFish(fish) {
        // 根据鱼的类型绘制不同的图片
        let fishImage = new Image();
        fishImage.src = getFishImageSrc(fish.type); // 根据鱼的类型获取图片源
        if (fishImage && fishImage.complete) {  // 确保图片已加载完成
            // 调整绘制坐标以使鱼的中心在(x, y)上
            const x = fish.x - fishImage.width / 2;
            const y = fish.y - fishImage.height / 2;
            ctx.drawImage(fishImage, x, y);
        }
    }

    function getFishImageSrc(fishType) {
        // 返回对应鱼类型的图片URL
        let fishImages = {
            'Fish_001': 'public/assets/img/fish_001.png',
            'Fish_002': 'public/assets/img/fish_002.png'
            // ...其他鱼的图片...
        };
        return fishImages[fishType] || 'path/to/default_fish.png';
    }

    update();
</script>
</body>
</html>
